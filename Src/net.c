#include "main.h"
#include "stm32h7xx_hal.h"
#include "stm32h7xx_hal_fdcan.h"
#include "net.h"
#include "helpers.h"

#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include "lwip.h"
#include "lwip/udp.h"
#include "lwip/igmp.h"

#include "stm32h7xx_ll_spi.h"

#include "lcmlite.h"

#include "hl_command_msg.h"
#include "hl_state_msg.h"
//-----------------------------------------------
struct udp_pcb *upcb;

lcmlite_t lcm;

#define LOCAL_PORT 1555
#define REMOTE_PORT 1556
uint8_t RMT_IP_ADDRESS[4] = {192,168,2,105};

struct udp_pcb *upcb_1;

extern FDCAN_HandleTypeDef * FDCAN_Handles_Map[3];
extern buffer_instance * TX_Buffers_Map[3];

char hl_command_charname[] = "EXAMPLE";

uint8_t LCM_rx_flag = 0;

//-----------------------------------------------
static inline float ReverseFloat( const float inFloat );
void udp_receive_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port);

hl_command_msg rx_lcm_msg = {0};
uint64_t hl_command_hash = 0xddee7eb091a55d19; // reversed form of the value generated by LCM-gen = 0x195da591b07eeedd

//#pragma optimize s=none
static void hl_command_callback(lcmlite_t *lcm, const char *channel, const void *buf, int buf_len, void *user)
{
  // the first 64 bits of provided buffer contain hash number,
  // which is unique for the message type (see LCM generated headers)
  uint64_t buf_msg_hash;
  memcpy( &buf_msg_hash, (uint8_t*)buf, 8);
  
  if( buf_msg_hash != hl_command_hash )
  {
    Error_Handler();
  }
  
  // copy the data from the provided buffer into the global LCM ctucture
  // reverse data from the big-endian into small-endian simultaneously
  for( int i = 0; i < sizeof(rx_lcm_msg); i += 4)
  {
    float var;
    memcpy( &var, (uint8_t*)buf + 8 + i, 4);
    var = ReverseFloat(var);
    memcpy( (uint8_t*)&rx_lcm_msg + i, &var, 4);
  }
  
  LCM_rx_flag = 1;
  
  return ;
}

measurment tx_lcm_msg = {0};
uint8_t lcm_tx_buf[512] = {0};
uint64_t measurment_hash = 0x5f3bf46b0e2209da;

void conke(void)
{
    for( int i = 0; i < 12; i++ )
  {
    tx_lcm_msg.act[i].position = i*1.0f + 0.1f;
    tx_lcm_msg.act[i].velocity = i*1.0f + 0.2f;
    tx_lcm_msg.act[i].torque = i*1.0f + 0.3f;
  }
  
  memcpy( &lcm_tx_buf, &measurment_hash, 8);

  for( int i = 0; i < sizeof(tx_lcm_msg); i += 4)
  {
    float var;
    memcpy( &var, (uint8_t*)&tx_lcm_msg + i, 4);
    var = ReverseFloat(var);
    memcpy( (uint8_t*)&lcm_tx_buf + 8 + i, &var, 4);
  }
  
  lcmlite_publish(&lcm, "UPSTREAM", &lcm_tx_buf, sizeof(tx_lcm_msg) + 8);
}

ip_addr_t Multicast_Addr;
void transmit_packet(const void *_buf, int buf_len, void *user)
{
  struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, buf_len, PBUF_RAM); // allocate LWIP memory for outgoing UDP packet

  if (p != NULL)
  {
    pbuf_take(p, (void *) _buf, buf_len);
    udp_sendto(upcb_1, p, &Multicast_Addr, 1557);
    //udp_send(upcb_1, p);
    pbuf_free(p);
  }
  else
  {
    Error_Handler();
  }
  
  return ;
}

//-----------------------------------------------
void lcm_receive_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
  lcmlite_receive_packet( &lcm, p->payload, p->len, NULL);
  pbuf_free(p);
  return ;
}
//-----------------------------------------------
void udp_lcm_connect(void)
{
  IP4_ADDR(&Multicast_Addr, 224, 0, 0, 7 ); 
#if LWIP_IGMP
    igmp_joingroup(IP_ADDR_ANY,&Multicast_Addr);
#endif
    
  err_t err;
  upcb_1 = udp_new();
  if (upcb_1!=NULL)
  {
    upcb_1->local_port = LOCAL_PORT;
    err= udp_bind(upcb_1, IP_ADDR_ANY, 1557);
    //err= udp_connect(upcb_1, &Multicast_Addr, 1557);
    if (err == ERR_OK)
    {
      udp_recv(upcb_1, lcm_receive_callback, NULL);
    }
  }
  
  lcmlite_init(&lcm, transmit_packet, NULL);
  
  // subscribe to HL_COMMAND messages
  lcmlite_subscription_t *sub = malloc(sizeof(lcmlite_subscription_t));
  sub->channel = hl_command_charname;
  sub->callback = hl_command_callback;
  sub->user = NULL;
  lcmlite_subscribe(&lcm, sub);  
}
//-----------------------------------------------

void udp_client_connect(void)
{
  ip_addr_t DestIPaddr;
  err_t err;
  upcb = udp_new();
  if (upcb!=NULL)
  {
    IP4_ADDR(&DestIPaddr, RMT_IP_ADDRESS[0], RMT_IP_ADDRESS[1], RMT_IP_ADDRESS[2], RMT_IP_ADDRESS[3]);
    upcb->local_port = LOCAL_PORT;
    err= udp_connect(upcb, &DestIPaddr, REMOTE_PORT);
    if (err == ERR_OK)
    {
      udp_recv(upcb, udp_receive_callback, NULL);
    }
  }
}
//-----------------------------------------------

extern buffer_instance gaga;
uint8_t debug_buf[128] = {0};

void udp_client_send(void)
{
  // make a local copy of buffer variables to allow concurrent write access to the global buffer
  uint16_t bytes = gaga.bytes_written;
  uint16_t head0 = gaga.head;
  uint16_t tail0 = gaga.tail;

  if( bytes == 0 )
  {
    // no data to process
    return ; 
  }
  
  memset(debug_buf, 0, 128);

  struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, bytes, PBUF_RAM); // allocate LWIP memory for outgoing UDP packet
  
  memcpy(debug_buf, p->payload, 128);
    
  if (p != NULL)
  {
    if( bytes < buf_size - head0 )
    {
      // memcpy in one step - written data gapless
      pbuf_take(p, (void *) &gaga.buffer_body[head0], bytes);
      memcpy(debug_buf, p->payload, 128);
    }
    else
    {
      // memcpy in two steps - data is divided in two parts - at the end and the beginning of circular buffer
      pbuf_take(p, (void *) &gaga.buffer_body[head0], buf_size - head0);
      pbuf_take_at(p, (void *) gaga.buffer_body, tail0, buf_size - head0);
      memcpy(debug_buf, p->payload, 128);
    }
    
    memcpy(debug_buf, p->payload, 128);

    udp_send(upcb, p);
    pbuf_free(p);
    gaga.bytes_written -= bytes;
    gaga.head = tail0;
  }
  else
  {
    // ran out of memory? 
    Error_Handler();
  }
}

uint8_t companion_TX_buf[buf_size] = {0};
buffer_instance companion_TX_ins = {0, NULL, 0, companion_TX_buf};

volatile uint32_t debug_counter = 0;

// this function serves as abstraction layer between application-level can-buses
// and actual can-hardware on the main or companion chip. 
void distribute_vb_frame( uint8_t * vb_frame )
{
  uint8_t vb_frame_len = vb_frame[0];
  uint32_t bus_id = 0;
  memcpy(&bus_id, &vb_frame[1], 4);
  uint8_t bus_num = decode_bus_num( bus_id );
  
  if( bus_num < 3 )
  {
    FDCAN_HandleTypeDef * FDCAN_Handle = FDCAN_Handles_Map[bus_num];
    buffer_instance *TX_buffer = TX_Buffers_Map[bus_num];
    
    if( FDCAN_Handle != NULL )
    {    
      if( HAL_FDCAN_GetTxFifoFreeLevel(FDCAN_Handle) > 0 )
      {
        // if interrupt fires right now it will try access TX_buffer in line below
        push_can_frame( FDCAN_Handle, vb_frame, vb_frame_len);
      }
      else
      {
        // this section should be critical
        uint32_t primask_bit = __get_PRIMASK();       // backup PRIMASK bit
        __disable_irq();                              // Disable all interrupts by setting PRIMASK bit on Cortex
          write_buffer(TX_buffer, vb_frame, vb_frame_len); // write message length
        __set_PRIMASK(primask_bit);                   // Restore PRIMASK bit
      }
    }
    else
    {
      // this bus is disabled
    }
  }
  else
  {
    debug_counter++;
    // SPI transfer section. 
    // There's at least one frame ready to be processed. 
    // If no outgoing SPI transfers happens (1st frame in series), load it directly into the SPI FIFO.
    
    uint32_t primask_bit = __get_PRIMASK();   // backup PRIMASK bit
    __disable_irq();                          // Disable all interrupts by setting PRIMASK bit on Cortex
      // while we are accessing the buffer the SPI interrupt can occur - it will corrupt it. 
      write_buffer(&companion_TX_ins, vb_frame, vb_frame_len); // write message length
    __set_PRIMASK(primask_bit);               // Restore PRIMASK bit
    
    if( !LL_SPI_IsActiveMasterTransfer(SPI1) )
    {
      send_frame_SPI();
    }
  }
}

void udp_receive_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
  uint8_t * data = p->payload; // pointer to the dynamically allocated UDP packet payload buffer. safe to use untill buffer is freed. 
  uint16_t packet_length = p->len;

  uint16_t index = 0; // specifies number of bytes read from the udp packet. 
  
  while( index < packet_length ) // iterate over UDP packet
  {
    // parse one vb frame from the rx UDP packet
    uint8_t vb_frame_length = data[index];
    
    distribute_vb_frame( &data[index] );

    index += vb_frame_length;
  }
  
  if( index != packet_length )
  {
    Error_Handler();
  }
  
  pbuf_free(p);
}
//-----------------------------------------------
void TIM1_Callback(void)
{
  //udp_client_send();
}
//--------------------------------------------------
static inline float ReverseFloat( const float inFloat )
{
   float retVal;
   char *floatToConvert = ( char* ) & inFloat;
   char *returnFloat = ( char* ) & retVal;

   // swap the bytes into a temporary buffer
   returnFloat[0] = floatToConvert[3];
   returnFloat[1] = floatToConvert[2];
   returnFloat[2] = floatToConvert[1];
   returnFloat[3] = floatToConvert[0];

   return retVal;
}