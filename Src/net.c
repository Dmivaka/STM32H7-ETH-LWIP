#include "main.h"
#include "stm32h7xx_hal.h"
#include "stm32h7xx_hal_fdcan.h"
#include "net.h"
#include "helpers.h"

#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include "lwip.h"
#include "lwip/udp.h"
#include "lwip/igmp.h"

#include "stm32h7xx_ll_spi.h"

#include "lcmlite.h"

#include "hl_command_msg.h"
#include "hl_state_msg.h"

#include "circular_heap.h"
//-----------------------------------------------
struct udp_pcb *upcb;

lcmlite_t lcm;

#define LOCAL_PORT 1555
#define REMOTE_PORT 1556
uint8_t RMT_IP_ADDRESS[4] = {192,168,2,105};

struct udp_pcb *upcb_1;

extern FDCAN_HandleTypeDef * FDCAN_Handles_Map[3];

char hl_command_charname[] = "EXAMPLE";

uint8_t LCM_rx_flag = 0;
uint8_t LCM_tx_flag = 0;

//-----------------------------------------------
static inline float ReverseFloat( const float inFloat );
void udp_receive_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port);

hl_command_msg rx_lcm_msg = {0};
uint64_t hl_command_hash = 0xddee7eb091a55d19; // reversed form of the value generated by LCM-gen = 0x195da591b07eeedd

//#pragma optimize s=none
static void hl_command_callback(lcmlite_t *lcm, const char *channel, const void *buf, int buf_len, void *user)
{
  // the first 64 bits of provided buffer contain hash number,
  // which is unique for the message type (see LCM generated headers)
  uint64_t buf_msg_hash;
  memcpy( &buf_msg_hash, (uint8_t*)buf, 8);
  
  if( buf_msg_hash != hl_command_hash )
  {
    Error_Handler();
  }
  
  // copy the data from the provided buffer into the global LCM ctucture
  // reverse data from the big-endian into small-endian simultaneously
  for( int i = 0; i < sizeof(rx_lcm_msg); i += 4)
  {
    float var;
    memcpy( &var, (uint8_t*)buf + 8 + i, 4);
    var = ReverseFloat(var);
    memcpy( (uint8_t*)&rx_lcm_msg + i, &var, 4);
  }
  
  LCM_rx_flag = 1;
  
  return ;
}

measurment tx_lcm_msg = {0};
uint8_t lcm_tx_buf[512] = {0};
uint64_t measurment_hash = 0x5f3bf46b0e2209da;

void conke(void)
{
  /*
  for( int i = 0; i < 12; i++ )
  {
    tx_lcm_msg.act[i].position = i*1.0f + 0.1f;
    tx_lcm_msg.act[i].velocity = i*1.0f + 0.2f;
    tx_lcm_msg.act[i].torque = i*1.0f + 0.3f;
  }
  */
  memcpy( &lcm_tx_buf, &measurment_hash, 8);

  for( int i = 0; i < sizeof(tx_lcm_msg); i += 4)
  {
    float var;
    memcpy( &var, (uint8_t*)&tx_lcm_msg + i, 4);
    var = ReverseFloat(var);
    memcpy( (uint8_t*)&lcm_tx_buf + 8 + i, &var, 4);
  }
  
  lcmlite_publish(&lcm, "UPSTREAM", &lcm_tx_buf, sizeof(tx_lcm_msg) + 8);
}

ip_addr_t Multicast_Addr;
void transmit_LCM_packet(const void *_buf, int buf_len, void *user)
{
  struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, buf_len, PBUF_RAM); // allocate LWIP memory for outgoing UDP packet

  if (p != NULL)
  {
    pbuf_take(p, (void *) _buf, buf_len);
    udp_sendto(upcb_1, p, &Multicast_Addr, 1557);
    //udp_send(upcb_1, p);
    pbuf_free(p);
  }
  else
  {
    Error_Handler();
  }
  
  return ;
}

//-----------------------------------------------
void lcm_receive_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
  lcmlite_receive_packet( &lcm, p->payload, p->len, NULL);
  pbuf_free(p);
  return ;
}
//-----------------------------------------------
void udp_lcm_connect(void)
{
  IP4_ADDR(&Multicast_Addr, 224, 0, 0, 7 ); 
#if LWIP_IGMP
    igmp_joingroup(IP_ADDR_ANY,&Multicast_Addr);
#endif
    
  err_t err;
  upcb_1 = udp_new();
  if (upcb_1!=NULL)
  {
    upcb_1->local_port = LOCAL_PORT;
    err= udp_bind(upcb_1, IP_ADDR_ANY, 1557);
    //err= udp_connect(upcb_1, &Multicast_Addr, 1557);
    if (err == ERR_OK)
    {
      udp_recv(upcb_1, lcm_receive_callback, NULL);
    }
  }
  
  lcmlite_init(&lcm, transmit_LCM_packet, NULL);
  
  // subscribe to HL_COMMAND messages
  lcmlite_subscription_t *sub = malloc(sizeof(lcmlite_subscription_t));
  sub->channel = hl_command_charname;
  sub->callback = hl_command_callback;
  sub->user = NULL;
  lcmlite_subscribe(&lcm, sub);  
}
//-----------------------------------------------

void udp_client_connect(void)
{
  ip_addr_t DestIPaddr;
  err_t err;
  upcb = udp_new();
  if (upcb!=NULL)
  {
    IP4_ADDR(&DestIPaddr, RMT_IP_ADDRESS[0], RMT_IP_ADDRESS[1], RMT_IP_ADDRESS[2], RMT_IP_ADDRESS[3]);
    upcb->local_port = LOCAL_PORT;
    err= udp_connect(upcb, &DestIPaddr, REMOTE_PORT);
    if (err == ERR_OK)
    {
      udp_recv(upcb, udp_receive_callback, NULL);
    }
  }
}

//-----------------------------------------------
extern queue spi_tx_queue;
extern circular_heap_t spi_tx_heap;

extern queue *can_tx_queues[3];
extern circular_heap_t *can_tx_heaps[3];

volatile uint32_t debug_counter = 0;

// this function serves as abstraction layer between application-level can-buses
// and actual can-hardware on the main or companion chip. 
void distribute_vb_frame( uint8_t * vb_frame )
{
  uint8_t bus;
  uint32_t id;
  size_t frame_len;

  uint8_t *data_pointer = deserialize_can_frame( &bus, &id, &frame_len, NULL, vb_frame); // only extracts service info

  if( bus < 3 )
  {
    FDCAN_HandleTypeDef * FDCAN_Handle = FDCAN_Handles_Map[bus];

    if( FDCAN_Handle != NULL )
    {
      if( HAL_FDCAN_GetTxFifoFreeLevel(FDCAN_Handle) > 0 )
      {
        // if interrupt fires right now it will try access TX_buffer in line below
        push_can_frame( FDCAN_Handle, id, frame_len, data_pointer);
      }
      else
      {
        // this section should be critical
        uint32_t primask_bit = __get_PRIMASK();       // backup PRIMASK bit
        __disable_irq();                              // Disable all interrupts by setting PRIMASK bit on Cortex
        
          item* new_element = circular_heap_alloc( can_tx_heaps[bus], sizeof(void*) + frame_len + 5 );
          if( new_element != NULL )
          {
            memcpy( &new_element->payload, vb_frame, frame_len + 5 );
            enqueue( can_tx_queues[bus], new_element );
          }
          else
          {
            // buffer is full
          }

        __set_PRIMASK(primask_bit);                   // Restore PRIMASK bit
      }
    }
    else
    {
      // this bus is disabled
    }
  }
  else
  {
    debug_counter++;
    // SPI transfer section. 
    // There's at least one frame ready to be processed. 
    // If no outgoing SPI transfers happens (1st frame in series), load it directly into the SPI FIFO.
    
    uint32_t primask_bit = __get_PRIMASK();   // backup PRIMASK bit
    __disable_irq();                          // Disable all interrupts by setting PRIMASK bit on Cortex
      // while we are accessing the buffer the SPI interrupt can occur - it will corrupt it. 

      item* new_element = circular_heap_alloc( &spi_tx_heap, sizeof(void*) + frame_len + 5 );
      if( new_element != NULL )
      {
        memcpy( &new_element->payload, vb_frame, frame_len + 5 );
        enqueue( &spi_tx_queue, new_element );
      }
      else
      {
        // buffer is full
      }
      
    __set_PRIMASK(primask_bit);               // Restore PRIMASK bit
    
    if( !LL_SPI_IsActiveMasterTransfer(SPI1) )
    {
      send_frame_SPI();
    }
  }
}

void udp_receive_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
  uint8_t * data = p->payload; // pointer to the dynamically allocated UDP packet payload buffer. safe to use untill buffer is freed. 
  uint16_t packet_length = p->len;

  uint16_t index = 0; // specifies number of bytes read from the udp packet. 
  
  while( index < packet_length ) // iterate over UDP packet
  {
    // parse one vb frame from the rx UDP packet
    uint8_t vb_frame_length = data[index];

    distribute_vb_frame( &data[index] );

    index += vb_frame_length;
  }
  
  if( index != packet_length )
  {
    Error_Handler();
  }
  
  pbuf_free(p);
}
//-----------------------------------------------
void TIM1_Callback(void)
{
  //udp_client_send();
}
//--------------------------------------------------
static inline float ReverseFloat( const float inFloat )
{
   float retVal;
   char *floatToConvert = ( char* ) & inFloat;
   char *returnFloat = ( char* ) & retVal;

   // swap the bytes into a temporary buffer
   returnFloat[0] = floatToConvert[3];
   returnFloat[1] = floatToConvert[2];
   returnFloat[2] = floatToConvert[1];
   returnFloat[3] = floatToConvert[0];

   return retVal;
}